<!DOCTYPE html>
<html>

<head>
	<title>高等計算機圖學HW02</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<link type="text/css" rel="stylesheet" href="main.css">
	<style>
		body {
			background-color: #fff;
			color: #444;
		}

		a {
			color: #08f;
		}
	</style>
</head>

<body>
	<div id="info"></div>
	<script src="js/libs/ammo.wasm.js"></script>
	<script src="scoreoutputer.min.js"></script>
	<script>
		var so = new ScoreOutputer("110598080");
		so.installCSS(function () {
			so.addChild("視角可以移動及放大", 2, true);
			so.addChild("在畫面上畫出左眼的邊框", 2, true);
			so.addChild("複製左眼邊框變化到右眼", 2, true);
			so.addChild("可選擇當前讀取角色或按鍵選擇上 / 下一隻角色", 1, true);
			so.addChild("可儲存座標點檔案", 1, true);
			so.addChild("回答問題", 2, true);
			//產生自評表，參數如下所示
			so.renderModal(
				document.body,
				'rgba(163,148,128,1)',
				'white',
				'15pt',
				'15px',
				dialogTitle = "自我評分表"
			);
			//設定下載按鈕 <-- 一定要呼叫這個函數，不然沒有下載功能
			so.installDownloadBtn();
			//產生 "開啟自評表按鈕"
			so.renderBtn(
				//自評表按鈕插入位置
				// document.body,
				document.querySelector("#info"),
				//自評表按鈕文字
				"開啟自評表"
			);
		});
	</script>
	<script type="module">

		import * as THREE from './build/three.module.js';
		import { GUI } from './jsm/libs/dat.gui.module.js';
		import { OrbitControls } from './jsm/controls/OrbitControls.js';
		import { OutlineEffect } from './jsm/effects/OutlineEffect.js';
		import { MMDLoader } from './jsm/loaders/MMDLoader.js';
		import { MMDAnimationHelper } from './jsm/animation/MMDAnimationHelper.js';

		let camera, scene, renderer, effect;
		let mesh, helper; 
		let mode = 0;
		let modelNum = 0;
		let line1, line2, line3, line4;
		let line01, line02, line03, line04;
		let l1, l2, l3, l4;
		let x1, x2, x3, x4, y1, y2, y3, y4;
		let modelFile_List = ['models/mmd/kizunaai/kizunaai.pmx',
							  'models/mmd/『天宮こころ(Kokoro Amamiya)』/『天宮こころ(Kokoro Amamiya)』.pmx',
							  'models/mmd/るいのれ式物述有栖_配布用フォルダ/物述有栖.pmx'];
		let save_data = {
			"modellist":[
				{
					"location":modelFile_List[0],
					"line_locationx_1":0,
					"line_locationy_1":0,
					"line_locationx_2":0,
					"line_locationy_2":0,
					"line_locationx_3":0,
					"line_locationy_3":0,
					"line_locationx_4":0,
					"line_locationy_4":0
				},
				{
					"location":modelFile_List[1],
					"line_locationx_1":0,
					"line_locationy_1":0,
					"line_locationx_2":0,
					"line_locationy_2":0,
					"line_locationx_3":0,
					"line_locationy_3":0,
					"line_locationx_4":0,
					"line_locationy_4":0
				},
				{
					"location":modelFile_List[2],
					"line_locationx_1":0,
					"line_locationy_1":0,
					"line_locationx_2":0,
					"line_locationy_2":0,
					"line_locationx_3":0,
					"line_locationy_3":0,
					"line_locationx_4":0,
					"line_locationy_4":0
				}
			]
		};

		const vpds = [];

		Ammo().then(function (AmmoLib) {

			Ammo = AmmoLib;

			init();
			animate();

		});

		function onKeyCode(keyboard) {
			console.log('keycode = ' + keyboard.keyCode);
			if ( keyboard.keyCode == 49 ) mode = 1; //key = 1
			else if ( keyboard.keyCode == 50 ) mode = 2; //key = 2
			else if ( keyboard.keyCode == 51 ) mode = 3; //key = 3
			else if ( keyboard.keyCode == 52 ) mode = 4; //key = 4
			else if ( keyboard.keyCode == 81 ) //key = q, copy to right eye
			{
				mode = 5;

				const points01 = [];
				points01.push( new THREE.Vector3( 0, l1, 20 ) );
				points01.push( new THREE.Vector3( - 10, l1, 20 ) );

				const points02 = [];
				points02.push( new THREE.Vector3( l2, - 0.5, 20 ) );
				points02.push( new THREE.Vector3( l2, 9.5, 20 ) );

				const points03 = [];
				points03.push( new THREE.Vector3( 0, l3, 20 ) );
				points03.push( new THREE.Vector3( - 10, l3, 20 ) );

				const points04 = [];
				points04.push( new THREE.Vector3( l4, - 0.5, 20 ) );
				points04.push( new THREE.Vector3( l4, 9.5, 20 ) );

				const line01_material = new THREE.LineBasicMaterial({ color: 0xff00ff }); //Purple
				const line02_material = new THREE.LineBasicMaterial({ color: 0x66b3ff }); //BabyBlue

				const line01_geometry = new THREE.BufferGeometry().setFromPoints( points01 );
				const line02_geometry = new THREE.BufferGeometry().setFromPoints( points02 );
				const line03_geometry = new THREE.BufferGeometry().setFromPoints( points03 );
				const line04_geometry = new THREE.BufferGeometry().setFromPoints( points04 );

				line01 = new THREE.Line( line01_geometry, line01_material );
				line02 = new THREE.Line( line02_geometry, line02_material );
				line03 = new THREE.Line( line03_geometry, line01_material );
				line04 = new THREE.Line( line04_geometry, line02_material );

				line01.name = "removeline01";
				var selectedObject01 = scene.getObjectByName("removeline01");
				scene.remove(selectedObject01);
				line02.name = "removeline02";
				var selectedObject02 = scene.getObjectByName("removeline02");
				scene.remove(selectedObject02);
				line03.name = "removeline03";
				var selectedObject03 = scene.getObjectByName("removeline03");
				scene.remove(selectedObject03);
				line04.name = "removeline04";
				var selectedObject04 = scene.getObjectByName("removeline04");
				scene.remove(selectedObject04);
				
				scene.add( line01 );
				scene.add( line02 );
				scene.add( line03 );
				scene.add( line04 );
			}
			else if ( keyboard.keyCode == 83 ) saveJson(); //key = s, saved by json
		}

		var body = document.body;

		function getPosition(e) {
			var mouseWorld = new THREE.Vector3();
			const { left, top, width, height } = e.currentTarget.getBoundingClientRect();

			mouseWorld.set(
				((e.clientX - left + 1) / window.innerWidth) * 2 - 1,
				-((e.clientY - top + 1) / window.innerHeight) * 2 + 1,
				(camera.near + camera.far) / (camera.near - camera.far),
			);

			mouseWorld.unproject(camera);

			const points1 = [];
			points1.push( new THREE.Vector3( 0, mouseWorld.y, 20 ) );
			points1.push( new THREE.Vector3( 10, mouseWorld.y, 20 ) );

			const points2 = [];
			points2.push( new THREE.Vector3( mouseWorld.x, - 0.5, 20 ) );
			points2.push( new THREE.Vector3( mouseWorld.x, 9.5, 20 ) );
				
			const line1_material = new THREE.LineBasicMaterial({ color: 0xff0000 }); //Red
			const line2_material = new THREE.LineBasicMaterial({ color: 0x00ff00 }); //Green

			const line1_geometry = new THREE.BufferGeometry().setFromPoints( points1 );
			const line2_geometry = new THREE.BufferGeometry().setFromPoints( points2 );

			line1 = new THREE.Line( line1_geometry, line1_material );
			line2 = new THREE.Line( line2_geometry, line2_material );
			line3 = new THREE.Line( line1_geometry, line1_material );
			line4 = new THREE.Line( line2_geometry, line2_material );

			document.onclick = function () {
				if ( mode == 1 ) {
					line1.name = "removeline1";
					var selectedObject = scene.getObjectByName("removeline1");
					scene.remove(selectedObject);
					scene.add( line1 );
					l1 = mouseWorld.y;
					x1 = mouseWorld.x;
					y1 = l1;
					console.log('(x1, y1) = ' + x1 + '.' + y1 );
					save_data.modellist[modelNum].line_locationx_1 = x1;
					save_data.modellist[modelNum].line_locationy_1 = y1;
				}else if ( mode == 2 ) {
					line2.name = "removeline2";
					var selectedObject = scene.getObjectByName("removeline2");
					scene.remove(selectedObject);
					scene.add( line2 );
					l2 = - mouseWorld.x;
					x2 = - l2;
					y2 = mouseWorld.y;
					console.log('(x2, y2) = ' + x2 + '.' + y2);
					save_data.modellist[modelNum].line_locationx_2 = x2;
					save_data.modellist[modelNum].line_locationy_2 = y2;
				}else if ( mode == 3 ) {
					line3.name = "removeline3";
					var selectedObject = scene.getObjectByName("removeline3");
					scene.remove(selectedObject);
					scene.add( line3 );
					l3 = mouseWorld.y;
					x3 = mouseWorld.x;
					y3 = l3;
					console.log('(x3, y3) = ' + x3 + '.' + y3);
					save_data.modellist[modelNum].line_locationx_3 = x3;
					save_data.modellist[modelNum].line_locationy_3 = y3;
				}else if ( mode == 4 ) {
					line4.name = "removeline4";
					var selectedObject = scene.getObjectByName("removeline4");
					scene.remove(selectedObject);
					scene.add( line4 );
					l4 = - mouseWorld.x;
					x4 = - l4;
					y4 = mouseWorld.y;
					console.log('(x4, y4) = ' + x4 + '.' + y4);
					save_data.modellist[modelNum].line_locationx_4 = x4;
					save_data.modellist[modelNum].line_locationy_4 = y4;
				}
			}
		}
		body.addEventListener('mousemove', getPosition, false);

		function saveJson() {
			var data_string = JSON.stringify(save_data);
			var blob = new Blob([data_string], {type : "text/plain; charset = utf-8"});
			var aLink = document.createElement('a');
			var evt = document.createEvent("HTMLEvents");
			evt.initEvent("click");
			aLink.download = 'save_model_data.json';
			aLink.href = URL.createObjectURL(blob);
			aLink.dispatchEvent(evt);
			aLink.click();
		}

		function init() {

			const container = document.createElement('div');
			// container.classList.add("three");
			document.body.appendChild(container);
			let scale = 30;
			camera = new THREE.OrthographicCamera(window.innerWidth / scale / - 2, window.innerWidth / scale / 2, window.innerHeight / scale / 2, window.innerHeight / scale / - 2, 0.1, 1000);
			//camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 2000 );
			camera.position.z = 25;

			// scene

			scene = new THREE.Scene();
			scene.background = new THREE.Color(0xffffff);

			const ambient = new THREE.AmbientLight(0x666666);
			scene.add(ambient);

			const directionalLight = new THREE.DirectionalLight(0x887766);
			directionalLight.position.set(- 1, 1, 1).normalize();
			scene.add(directionalLight);

			//
			renderer = new THREE.WebGLRenderer({ antialias: true });
			renderer.setPixelRatio(window.devicePixelRatio);
			renderer.setSize(window.innerWidth, window.innerHeight);
			container.appendChild(renderer.domElement);

			effect = new OutlineEffect(renderer);

			// model

			function onProgress(xhr) {

				if (xhr.lengthComputable) {

					const percentComplete = xhr.loaded / xhr.total * 100;
					console.log(Math.round(percentComplete, 2) + '% downloaded');

				}

			}

			const modelFile = 'models/mmd/kizunaai/kizunaai.pmx';
			// const modelFile = 'models/mmd/『天宮こころ(Kokoro Amamiya)』/『天宮こころ(Kokoro Amamiya)』.pmx';
			// const modelFile = 'models/mmd/るいのれ式物述有栖_配布用フォルダ/物述有栖.pmx';
			
			const vpdFiles = [
				'models/mmd/vpds/01.vpd',
				'models/mmd/vpds/02.vpd',
				'models/mmd/vpds/03.vpd',
				'models/mmd/vpds/04.vpd',
				'models/mmd/vpds/05.vpd',
				'models/mmd/vpds/06.vpd',
				'models/mmd/vpds/07.vpd',
				'models/mmd/vpds/08.vpd',
				// 'models/mmd/vpds/09.vpd',
				// 'models/mmd/vpds/10.vpd',
				'models/mmd/vpds/11.vpd'
			];

			helper = new MMDAnimationHelper();

			const loader = new MMDLoader();

			console.log(loader)

			//loads character from specified dircetory and return the mesh file
			async function loadCharacterModel(characterAddress) {
				loader.load(characterAddress,(obj)=>{
					scene.remove(mesh);

					mesh = obj;
					mesh.position.y = -10;

					scene.add(mesh);
					console.log("Model Changed");
					console.log("모델：" + characterAddress);

					if ( characterAddress == 'models/mmd/kizunaai/kizunaai.pmx' ) modelNum = 0;
					else if ( characterAddress == 'models/mmd/『天宮こころ(Kokoro Amamiya)』/『天宮こころ(Kokoro Amamiya)』.pmx' ) modelNum = 1;
					else if ( characterAddress == 'models/mmd/るいのれ式物述有栖_配布用フォルダ/物述有栖.pmx' ) modelNum = 2;

					var selectedObject1 = scene.getObjectByName("removeline1");
					scene.remove(selectedObject1);
					var selectedObject2 = scene.getObjectByName("removeline2");
					scene.remove(selectedObject2);
					var selectedObject3 = scene.getObjectByName("removeline3");
					scene.remove(selectedObject3);
					var selectedObject4 = scene.getObjectByName("removeline4");
					scene.remove(selectedObject4);
					var selectedObject01 = scene.getObjectByName("removeline01");
					scene.remove(selectedObject01);
					var selectedObject02 = scene.getObjectByName("removeline02");
					scene.remove(selectedObject02);
					var selectedObject03 = scene.getObjectByName("removeline03");
					scene.remove(selectedObject03);
					var selectedObject04 = scene.getObjectByName("removeline04");
					scene.remove(selectedObject04);

				}, onProgress,null);
			}

			loader.load(modelFile, function (object) {

				mesh = object;
				mesh.position.y = - 10;

				scene.add(mesh);

				console.log("mesh:",mesh);

				let vpdIndex = 0;

				function loadVpd() {

					const vpdFile = vpdFiles[vpdIndex];

					loader.loadVPD(vpdFile, false, function (vpd) {

						vpds.push(vpd);

						vpdIndex++;

						if (vpdIndex < vpdFiles.length) {

							loadVpd();

						} else {

							initGui();

						}

					}, onProgress, null);

				}

				loadVpd();

			}, onProgress, null);

			//

			window.addEventListener('resize', onWindowResize);
			window.addEventListener('keydown', onKeyCode);
			//鏡頭控制
			const cameracontrols = new OrbitControls(camera, renderer.domElement);
			cameracontrols.minDistance = 10;
			cameracontrols.maxDistance = 100;
			cameracontrols.enableRotate = false;
			function initGui() {

				const gui = new GUI();

				const dictionary = mesh.morphTargetDictionary;

				const controls = {};
				const keys = [];

				const meshControls = {};

				const models = gui.addFolder("Models");///////////
				const poses = gui.addFolder('Poses');
				const morphs = gui.addFolder('Morphs');

				function getBaseName(s) {

					return s.slice(s.lastIndexOf('/') + 1);

				}

				function initControls() {

					for (const key in dictionary) {

						controls[key] = 0.0;

					}

					controls.pose = - 1;
					controls.models = 1;

					for (let i = 0; i < vpdFiles.length; i++) {

						controls[getBaseName(vpdFiles[i])] = false;

					}

				}

				function initKeys() {

					for (const key in dictionary) {

						keys.push(key);

					}

				}

				function initModel() {
					const modelfiles = {
						kizunaai:'models/mmd/kizunaai/kizunaai.pmx',
						kokoro:'models/mmd/『天宮こころ(Kokoro Amamiya)』/『天宮こころ(Kokoro Amamiya)』.pmx',
						物述有栖: 'models/mmd/るいのれ式物述有栖_配布用フォルダ/物述有栖.pmx'
					}
					models.add(controls, 'models', modelfiles).onChange(loadCharacterModel);
				}

				function initPoses() {

					const files = { default: - 1 };

					for (let i = 0; i < vpdFiles.length; i++) {

						files[getBaseName(vpdFiles[i])] = i;

					}

					poses.add(controls, 'pose', files).onChange(onChangePose);

				}

				function initMorphs() {

					for (const key in dictionary) {

						morphs.add(controls, key, 0.0, 1.0, 0.01).onChange(onChangeMorph);

					}

				}

				function onChangeMorph() {

					for (let i = 0; i < keys.length; i++) {

						const key = keys[i];
						const value = controls[key];
						mesh.morphTargetInfluences[i] = value;

					}

				}

				function onChangePose() {

					const index = parseInt(controls.pose);

					if (index === - 1) {

						mesh.pose();

					} else {

						helper.pose(mesh, vpds[index]);

					}

				}

				meshControls.showBoundingbox = () => {
					console.log("mesh attributes: ", mesh.geometry.attributes);
					console.log("bones: ", mesh.geometry.bones);
					var rawIndex = mesh.geometry.attributes.skinIndex;
					var rawWeight = mesh.geometry.attributes.skinWeight;
					var rawPosition = mesh.geometry.attributes.position;

					var skinIndex = [];
					for(var i = 0; i < rawIndex.count; i++){
						var vector = new THREE.Vector4().fromBufferAttribute(rawIndex, i);
						skinIndex.push(vector);
					}

					var weightIndex = [];
					for(var i = 0; i < rawWeight.count; i++){
						var ww = new THREE.Vector4().fromBufferAttribute(rawWeight, i);
						weightIndex.push(ww);
					}

					var posIndex = [];
					for(var i = 0; i < rawPosition.count; i++){
						var pp = new THREE.Vector3().fromBufferAttribute(rawPosition, i);
						posIndex.push(pp);
					}

					var LeyeBone = mesh.skeleton.bones.find(el => el.name === "左目");

					LeyeBone.rotation.y += 0.1;

					var eyeVerts = [];

					skinIndex.forEach((el,index)=>{
						if(el.x == LeyeBone.id || el.y == LeyeBone.id || el.z == LeyeBone.id || el.w == LeyeBone.id){
							eyeVerts.push(index);
						}
					})
					
				};

				gui.add(meshControls, 'showBoundingbox');

				initControls();
				initKeys();
				initModel();
				initPoses();
				initMorphs();

				onChangeMorph();
				onChangePose();

				models.open();
				// poses.open();
				// morphs.open();

			}

		}

		function onWindowResize() {

			let scale = 30;
			camera.left = window.innerWidth / scale / - 2;
			camera.right = window.innerWidth / scale / 2;
			camera.top = window.innerHeight / scale / 2;
			camera.bottom = window.innerHeight / scale / - 2;
			camera.updateProjectionMatrix();

			effect.setSize(window.innerWidth, window.innerHeight);

		}

		//

		function animate() {

			requestAnimationFrame(animate);
			render();

		}

		function render() {

			effect.render(scene, camera);

		}
	</script>

</body>

</html>